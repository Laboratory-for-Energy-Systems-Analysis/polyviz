<!--
Library     : d3blocks
Author      : E.Taskesen, O.Verver
Mail        : erdogant@gmail.com, oliver@sensibly.nl
Github      : https://github.com/d3blocks/d3blocks
Licensed    : GPL3
Forked      : Mike Bostock; https://observablehq.com/@d3/directed-chord-diagram
-->

<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>"wind turbine network connection construction, 750kW, onshore (unit, CA-QC), kg CO2-Eq"</title>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.2/d3.min.js"></script>
<script src="https://unpkg.com/topojson@3"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>

<script>
	// Copyright 2021, Observable Inc.
// Released under the ISC license.

function renderHtml(string) {
  const template = document.createElement("template");
  template.innerHTML = string;
  return document.importNode(template.content, true);
}

function renderSvg(string) {
  const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
  g.innerHTML = string;
  return g;
}

const html = Object.assign(hypertext(renderHtml, fragment => {
  if (fragment.firstChild === null) return null;
  if (fragment.firstChild === fragment.lastChild) return fragment.removeChild(fragment.firstChild);
  const span = document.createElement("span");
  span.appendChild(fragment);
  return span;
}), {fragment: hypertext(renderHtml, fragment => fragment)});

const svg = Object.assign(hypertext(renderSvg, g => {
  if (g.firstChild === null) return null;
  if (g.firstChild === g.lastChild) return g.removeChild(g.firstChild);
  return g;
}), {fragment: hypertext(renderSvg, g => {
  const fragment = document.createDocumentFragment();
  while (g.firstChild) fragment.appendChild(g.firstChild);
  return fragment;
})});

const
CODE_TAB = 9,
CODE_LF = 10,
CODE_FF = 12,
CODE_CR = 13,
CODE_SPACE = 32,
CODE_UPPER_A = 65,
CODE_UPPER_Z = 90,
CODE_LOWER_A = 97,
CODE_LOWER_Z = 122,
CODE_LT = 60,
CODE_GT = 62,
CODE_SLASH = 47,
CODE_DASH = 45,
CODE_BANG = 33,
CODE_EQ = 61,
CODE_DQUOTE = 34,
CODE_SQUOTE = 39,
CODE_QUESTION = 63,
STATE_DATA = 1,
STATE_TAG_OPEN = 2,
STATE_END_TAG_OPEN = 3,
STATE_TAG_NAME = 4,
STATE_BOGUS_COMMENT = 5,
STATE_BEFORE_ATTRIBUTE_NAME = 6,
STATE_AFTER_ATTRIBUTE_NAME = 7,
STATE_ATTRIBUTE_NAME = 8,
STATE_BEFORE_ATTRIBUTE_VALUE = 9,
STATE_ATTRIBUTE_VALUE_DOUBLE_QUOTED = 10,
STATE_ATTRIBUTE_VALUE_SINGLE_QUOTED = 11,
STATE_ATTRIBUTE_VALUE_UNQUOTED = 12,
STATE_AFTER_ATTRIBUTE_VALUE_QUOTED = 13,
STATE_SELF_CLOSING_START_TAG = 14,
STATE_COMMENT_START = 15,
STATE_COMMENT_START_DASH = 16,
STATE_COMMENT = 17,
STATE_COMMENT_LESS_THAN_SIGN = 18,
STATE_COMMENT_LESS_THAN_SIGN_BANG = 19,
STATE_COMMENT_LESS_THAN_SIGN_BANG_DASH = 20,
STATE_COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 21,
STATE_COMMENT_END_DASH = 22,
STATE_COMMENT_END = 23,
STATE_COMMENT_END_BANG = 24,
STATE_MARKUP_DECLARATION_OPEN = 25,
STATE_RAWTEXT = 26,
STATE_RAWTEXT_LESS_THAN_SIGN = 27,
STATE_RAWTEXT_END_TAG_OPEN = 28,
STATE_RAWTEXT_END_TAG_NAME = 29,
SHOW_COMMENT = 128,
SHOW_ELEMENT = 1,
TYPE_COMMENT = 8,
TYPE_ELEMENT = 1,
NS_SVG = "http://www.w3.org/2000/svg",
NS_XLINK = "http://www.w3.org/1999/xlink",
NS_XML = "http://www.w3.org/XML/1998/namespace",
NS_XMLNS = "http://www.w3.org/2000/xmlns/";

const svgAdjustAttributes = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map(name => [name.toLowerCase(), name]));

const svgForeignAttributes = new Map([
  ["xlink:actuate", NS_XLINK],
  ["xlink:arcrole", NS_XLINK],
  ["xlink:href", NS_XLINK],
  ["xlink:role", NS_XLINK],
  ["xlink:show", NS_XLINK],
  ["xlink:title", NS_XLINK],
  ["xlink:type", NS_XLINK],
  ["xml:lang", NS_XML],
  ["xml:space", NS_XML],
  ["xmlns", NS_XMLNS],
  ["xmlns:xlink", NS_XMLNS]
]);

function hypertext(render, postprocess) {
  return function({raw: strings}) {
    let state = STATE_DATA;
    let string = "";
    let tagNameStart; // either an open tag or an end tag
    let tagName; // only open; beware nesting! used only for rawtext
    let attributeNameStart;
    let attributeNameEnd;
    let nodeFilter = 0;

    for (let j = 0, m = arguments.length; j < m; ++j) {
      const input = strings[j];

      if (j > 0) {
        const value = arguments[j];
        switch (state) {
          case STATE_RAWTEXT: {
            if (value != null) {
              const text = `${value}`;
              if (isEscapableRawText(tagName)) {
                string += text.replace(/[<]/g, entity);
              } else if (new RegExp(`</${tagName}[\\s>/]`, "i").test(string.slice(-tagName.length - 2) + text)) {
                throw new Error("unsafe raw text"); // appropriate end tag
              } else {
                string += text;
              }
            }
            break;
          }
          case STATE_DATA: {
            if (value == null) {
              // ignore
            } else if (value instanceof Node
                || (typeof value !== "string" && value[Symbol.iterator])
                || (/(?:^|>)$/.test(strings[j - 1]) && /^(?:<|$)/.test(input))) {
              string += "<!--::" + j + "-->";
              nodeFilter |= SHOW_COMMENT;
            } else {
              string += `${value}`.replace(/[<&]/g, entity);
            }
            break;
          }
          case STATE_BEFORE_ATTRIBUTE_VALUE: {
            state = STATE_ATTRIBUTE_VALUE_UNQUOTED;
            let text;
            if (/^[\s>]/.test(input)) {
              if (value == null || value === false) {
                string = string.slice(0, attributeNameStart - strings[j - 1].length);
                break;
              }
              if (value === true || (text = `${value}`) === "") {
                string += "''";
                break;
              }
              const name = strings[j - 1].slice(attributeNameStart, attributeNameEnd);
              if ((name === "style" && isObjectLiteral(value)) || typeof value === "function") {
                string += "::" + j;
                nodeFilter |= SHOW_ELEMENT;
                break;
              }
            }
            if (text === undefined) text = `${value}`;
            if (text === "") throw new Error("unsafe unquoted empty string");
            string += text.replace(/^['"]|[\s>&]/g, entity);
            break;
          }
          case STATE_ATTRIBUTE_VALUE_UNQUOTED: {
            string += `${value}`.replace(/[\s>&]/g, entity);
            break;
          }
          case STATE_ATTRIBUTE_VALUE_SINGLE_QUOTED: {
            string += `${value}`.replace(/['&]/g, entity);
            break;
          }
          case STATE_ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
            string += `${value}`.replace(/["&]/g, entity);
            break;
          }
          case STATE_BEFORE_ATTRIBUTE_NAME: {
            if (isObjectLiteral(value)) {
              string += "::" + j + "=''";
              nodeFilter |= SHOW_ELEMENT;
              break;
            }
            throw new Error("invalid binding");
          }
          case STATE_COMMENT: break;
          default: throw new Error("invalid binding");
        }
      }

      for (let i = 0, n = input.length; i < n; ++i) {
        const code = input.charCodeAt(i);

        switch (state) {
          case STATE_DATA: {
            if (code === CODE_LT) {
              state = STATE_TAG_OPEN;
            }
            break;
          }
          case STATE_TAG_OPEN: {
            if (code === CODE_BANG) {
              state = STATE_MARKUP_DECLARATION_OPEN;
            } else if (code === CODE_SLASH) {
              state = STATE_END_TAG_OPEN;
            } else if (isAsciiAlphaCode(code)) {
              tagNameStart = i, tagName = undefined;
              state = STATE_TAG_NAME, --i;
            } else if (code === CODE_QUESTION) {
              state = STATE_BOGUS_COMMENT, --i;
            } else {
              state = STATE_DATA, --i;
            }
            break;
          }
          case STATE_END_TAG_OPEN: {
            if (isAsciiAlphaCode(code)) {
              state = STATE_TAG_NAME, --i;
            } else if (code === CODE_GT) {
              state = STATE_DATA;
            } else {
              state = STATE_BOGUS_COMMENT, --i;
            }
            break;
          }
          case STATE_TAG_NAME: {
            if (isSpaceCode(code)) {
              state = STATE_BEFORE_ATTRIBUTE_NAME;
              tagName = lower(input, tagNameStart, i);
            } else if (code === CODE_SLASH) {
              state = STATE_SELF_CLOSING_START_TAG;
            } else if (code === CODE_GT) {
              tagName = lower(input, tagNameStart, i);
              state = isRawText(tagName) ? STATE_RAWTEXT : STATE_DATA;
            }
            break;
          }
          case STATE_BEFORE_ATTRIBUTE_NAME: {
            if (isSpaceCode(code)) {
              // continue
            } else if (code === CODE_SLASH || code === CODE_GT) {
              state = STATE_AFTER_ATTRIBUTE_NAME, --i;
            } else if (code === CODE_EQ) {
              state = STATE_ATTRIBUTE_NAME;
              attributeNameStart = i + 1, attributeNameEnd = undefined;
            } else {
              state = STATE_ATTRIBUTE_NAME, --i;
              attributeNameStart = i + 1, attributeNameEnd = undefined;
            }
            break;
          }
          case STATE_ATTRIBUTE_NAME: {
            if (isSpaceCode(code) || code === CODE_SLASH || code === CODE_GT) {
              state = STATE_AFTER_ATTRIBUTE_NAME, --i;
              attributeNameEnd = i;
            } else if (code === CODE_EQ) {
              state = STATE_BEFORE_ATTRIBUTE_VALUE;
              attributeNameEnd = i;
            }
            break;
          }
          case STATE_AFTER_ATTRIBUTE_NAME: {
            if (isSpaceCode(code)) {
              // ignore
            } else if (code === CODE_SLASH) {
              state = STATE_SELF_CLOSING_START_TAG;
            } else if (code === CODE_EQ) {
              state = STATE_BEFORE_ATTRIBUTE_VALUE;
            } else if (code === CODE_GT) {
              state = isRawText(tagName) ? STATE_RAWTEXT : STATE_DATA;
            } else {
              state = STATE_ATTRIBUTE_NAME, --i;
              attributeNameStart = i + 1, attributeNameEnd = undefined;
            }
            break;
          }
          case STATE_BEFORE_ATTRIBUTE_VALUE: {
            if (isSpaceCode(code)) {
              // continue
            } else if (code === CODE_DQUOTE) {
              state = STATE_ATTRIBUTE_VALUE_DOUBLE_QUOTED;
            } else if (code === CODE_SQUOTE) {
              state = STATE_ATTRIBUTE_VALUE_SINGLE_QUOTED;
            } else if (code === CODE_GT) {
              state = isRawText(tagName) ? STATE_RAWTEXT : STATE_DATA;
            } else {
              state = STATE_ATTRIBUTE_VALUE_UNQUOTED, --i;
            }
            break;
          }
          case STATE_ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
            if (code === CODE_DQUOTE) {
              state = STATE_AFTER_ATTRIBUTE_VALUE_QUOTED;
            }
            break;
          }
          case STATE_ATTRIBUTE_VALUE_SINGLE_QUOTED: {
            if (code === CODE_SQUOTE) {
              state = STATE_AFTER_ATTRIBUTE_VALUE_QUOTED;
            }
            break;
          }
          case STATE_ATTRIBUTE_VALUE_UNQUOTED: {
            if (isSpaceCode(code)) {
              state = STATE_BEFORE_ATTRIBUTE_NAME;
            } else if (code === CODE_GT) {
              state = isRawText(tagName) ? STATE_RAWTEXT : STATE_DATA;
            }
            break;
          }
          case STATE_AFTER_ATTRIBUTE_VALUE_QUOTED: {
            if (isSpaceCode(code)) {
              state = STATE_BEFORE_ATTRIBUTE_NAME;
            } else if (code === CODE_SLASH) {
              state = STATE_SELF_CLOSING_START_TAG;
            } else if (code === CODE_GT) {
              state = isRawText(tagName) ? STATE_RAWTEXT : STATE_DATA;
            } else {
              state = STATE_BEFORE_ATTRIBUTE_NAME, --i;
            }
            break;
          }
          case STATE_SELF_CLOSING_START_TAG: {
            if (code === CODE_GT) {
              state = STATE_DATA;
            } else {
              state = STATE_BEFORE_ATTRIBUTE_NAME, --i;
            }
            break;
          }
          case STATE_BOGUS_COMMENT: {
            if (code === CODE_GT) {
              state = STATE_DATA;
            }
            break;
          }
          case STATE_COMMENT_START: {
            if (code === CODE_DASH) {
              state = STATE_COMMENT_START_DASH;
            } else if (code === CODE_GT) {
              state = STATE_DATA;
            } else {
              state = STATE_COMMENT, --i;
            }
            break;
          }
          case STATE_COMMENT_START_DASH: {
            if (code === CODE_DASH) {
              state = STATE_COMMENT_END;
            } else if (code === CODE_GT) {
              state = STATE_DATA;
            } else {
              state = STATE_COMMENT, --i;
            }
            break;
          }
          case STATE_COMMENT: {
            if (code === CODE_LT) {
              state = STATE_COMMENT_LESS_THAN_SIGN;
            } else if (code === CODE_DASH) {
              state = STATE_COMMENT_END_DASH;
            }
            break;
          }
          case STATE_COMMENT_LESS_THAN_SIGN: {
            if (code === CODE_BANG) {
              state = STATE_COMMENT_LESS_THAN_SIGN_BANG;
            } else if (code !== CODE_LT) {
              state = STATE_COMMENT, --i;
            }
            break;
          }
          case STATE_COMMENT_LESS_THAN_SIGN_BANG: {
            if (code === CODE_DASH) {
              state = STATE_COMMENT_LESS_THAN_SIGN_BANG_DASH;
            } else {
              state = STATE_COMMENT, --i;
            }
            break;
          }
          case STATE_COMMENT_LESS_THAN_SIGN_BANG_DASH: {
            if (code === CODE_DASH) {
              state = STATE_COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
            } else {
              state = STATE_COMMENT_END, --i;
            }
            break;
          }
          case STATE_COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
            state = STATE_COMMENT_END, --i;
            break;
          }
          case STATE_COMMENT_END_DASH: {
            if (code === CODE_DASH) {
              state = STATE_COMMENT_END;
            } else {
              state = STATE_COMMENT, --i;
            }
            break;
          }
          case STATE_COMMENT_END: {
            if (code === CODE_GT) {
              state = STATE_DATA;
            } else if (code === CODE_BANG) {
              state = STATE_COMMENT_END_BANG;
            } else if (code !== CODE_DASH) {
              state = STATE_COMMENT, --i;
            }
            break;
          }
          case STATE_COMMENT_END_BANG: {
            if (code === CODE_DASH) {
              state = STATE_COMMENT_END_DASH;
            } else if (code === CODE_GT) {
              state = STATE_DATA;
            } else {
              state = STATE_COMMENT, --i;
            }
            break;
          }
          case STATE_MARKUP_DECLARATION_OPEN: {
            if (code === CODE_DASH && input.charCodeAt(i + 1) === CODE_DASH) {
              state = STATE_COMMENT_START, ++i;
            } else { // Note: CDATA and DOCTYPE unsupported!
              state = STATE_BOGUS_COMMENT, --i;
            }
            break;
          }
          case STATE_RAWTEXT: {
            if (code === CODE_LT) {
              state = STATE_RAWTEXT_LESS_THAN_SIGN;
            }
            break;
          }
          case STATE_RAWTEXT_LESS_THAN_SIGN: {
            if (code === CODE_SLASH) {
              state = STATE_RAWTEXT_END_TAG_OPEN;
            } else {
              state = STATE_RAWTEXT, --i;
            }
            break;
          }
          case STATE_RAWTEXT_END_TAG_OPEN: {
            if (isAsciiAlphaCode(code)) {
              tagNameStart = i;
              state = STATE_RAWTEXT_END_TAG_NAME, --i;
            } else {
              state = STATE_RAWTEXT, --i;
            }
            break;
          }
          case STATE_RAWTEXT_END_TAG_NAME: {
            if (isSpaceCode(code) && tagName === lower(input, tagNameStart, i)) {
              state = STATE_BEFORE_ATTRIBUTE_NAME;
            } else if (code === CODE_SLASH && tagName === lower(input, tagNameStart, i)) {
              state = STATE_SELF_CLOSING_START_TAG;
            } else if (code === CODE_GT && tagName === lower(input, tagNameStart, i)) {
              state = STATE_DATA;
            } else if (!isAsciiAlphaCode(code)) {
              state = STATE_RAWTEXT, --i;
            }
            break;
          }
          default: {
            state = undefined;
            break;
          }
        }
      }

      string += input;
    }

    const root = render(string);

    const walker = document.createTreeWalker(root, nodeFilter, null, false);
    const removeNodes = [];
    while (walker.nextNode()) {
      const node = walker.currentNode;
      switch (node.nodeType) {
        case TYPE_ELEMENT: {
          const attributes = node.attributes;
          for (let i = 0, n = attributes.length; i < n; ++i) {
            const {name, value: currentValue} = attributes[i];
            if (/^::/.test(name)) {
              const value = arguments[+name.slice(2)];
              removeAttribute(node, name), --i, --n;
              for (const key in value) {
                const subvalue = value[key];
                if (subvalue == null || subvalue === false) {
                  // ignore
                } else if (typeof subvalue === "function") {
                  node[key] = subvalue;
                } else if (key === "style" && isObjectLiteral(subvalue)) {
                  setStyles(node[key], subvalue);
                } else {
                  setAttribute(node, key, subvalue === true ? "" : subvalue);
                }
              }
            } else if (/^::/.test(currentValue)) {
              const value = arguments[+currentValue.slice(2)];
              removeAttribute(node, name), --i, --n;
              if (typeof value === "function") {
                node[name] = value;
              } else { // style
                setStyles(node[name], value);
              }
            }
          }
          break;
        }
        case TYPE_COMMENT: {
          if (/^::/.test(node.data)) {
            const parent = node.parentNode;
            const value = arguments[+node.data.slice(2)];
            if (value instanceof Node) {
              parent.insertBefore(value, node);
            } else if (typeof value !== "string" && value[Symbol.iterator]) {
              if (value instanceof NodeList || value instanceof HTMLCollection) {
                for (let i = value.length - 1, r = node; i >= 0; --i) {
                  r = parent.insertBefore(value[i], r);
                }
              } else {
                for (const subvalue of value) {
                  if (subvalue == null) continue;
                  parent.insertBefore(subvalue instanceof Node ? subvalue : document.createTextNode(subvalue), node);
                }
              }
            } else {
              parent.insertBefore(document.createTextNode(value), node);
            }
            removeNodes.push(node);
          }
          break;
        }
      }
    }

    for (const node of removeNodes) {
      node.parentNode.removeChild(node);
    }

    return postprocess(root);
  };
}

function entity(character) {
  return `&#${character.charCodeAt(0).toString()};`;
}

function isAsciiAlphaCode(code) {
  return (CODE_UPPER_A <= code && code <= CODE_UPPER_Z)
      || (CODE_LOWER_A <= code && code <= CODE_LOWER_Z);
}

function isSpaceCode(code) {
  return code === CODE_TAB
      || code === CODE_LF
      || code === CODE_FF
      || code === CODE_SPACE
      || code === CODE_CR; // normalize newlines
}

function isObjectLiteral(value) {
  return value && value.toString === Object.prototype.toString;
}

function isRawText(tagName) {
  return tagName === "script" || tagName === "style" || isEscapableRawText(tagName);
}

function isEscapableRawText(tagName) {
  return tagName === "textarea" || tagName === "title";
}

function lower(input, start, end) {
  return input.slice(start, end).toLowerCase();
}

function setAttribute(node, name, value) {
  if (node.namespaceURI === NS_SVG) {
    name = name.toLowerCase();
    name = svgAdjustAttributes.get(name) || name;
    if (svgForeignAttributes.has(name)) {
      node.setAttributeNS(svgForeignAttributes.get(name), name, value);
      return;
    }
  }
  node.setAttribute(name, value);
}

function removeAttribute(node, name) {
  if (node.namespaceURI === NS_SVG) {
    name = name.toLowerCase();
    name = svgAdjustAttributes.get(name) || name;
    if (svgForeignAttributes.has(name)) {
      node.removeAttributeNS(svgForeignAttributes.get(name), name);
      return;
    }
  }
  node.removeAttribute(name);
}

// We can’t use Object.assign because custom properties…
function setStyles(style, values) {
  for (const name in values) {
    const value = values[name];
    if (name.startsWith("--")) style.setProperty(name, value);
    else style[name] = value;
  }
}
	// Copyright 2021, Observable Inc.
// Released under the ISC license.
// https://observablehq.com/@d3/color-legend
function Swatches(color, {
  columns = null,
  format,
  unknown: formatUnknown,
  swatchSize = 15,
  swatchWidth = swatchSize,
  swatchHeight = swatchSize,
  marginLeft = 0
} = {}) {
  const id = `-swatches-${Math.random().toString(16).slice(2)}`;
  const unknown = formatUnknown == null ? undefined : color.unknown();
  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];
  const domain = color.domain().concat(unknowns);
  if (format === undefined) format = x => x === unknown ? formatUnknown : x;

  function entity(character) {
    return `&#${character.charCodeAt(0).toString()};`;
  }

  if (columns !== null) return html`<div style="display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 10px sans-serif;">
  <style>

.${id}-item {
  break-inside: avoid;
  display: flex;
  align-items: center;
  padding-bottom: 1px;
}

.${id}-label {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: calc(100% - ${+swatchWidth}px - 0.5em);
}

.${id}-swatch {
  width: ${+swatchWidth}px;
  height: ${+swatchHeight}px;
  margin: 0 0.5em 0 0;
}


  </style>
  <div style=${
    {width: "100%", columns}
     }>${domain.map(value => {
    const label = `${format(value)}`;
    return html`<div class=${id}-item>

      <div class=${id}-label title=${label}>${label}</div>
    </div>`;
  })}
  </div>
</div>`;

  return html`<div style="display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 10px sans-serif;">
  <style>

.${id} {
  display: inline-flex;
  align-items: center;
  margin-right: 1em;
}

.${id}::before {
  content: "";
  width: ${+swatchWidth}px;
  height: ${+swatchHeight}px;
  margin-right: 0.5em;
  background: var(--color);
}

  </style>
  <div>${domain.map(value => html`<span class="${id}" style="--color: ${color(value)}">${format(value)}</span>`)}</div>`;
}
	// Copyright 2021 Observable, Inc.
// Released under the ISC license.
// https://observablehq.com/@d3/treemap
function Treemap(data, { // data is either tabular (array of objects) or hierarchy (nested objects)
  path, // as an alternative to id and parentId, returns an array identifier, imputing internal nodes
  id = Array.isArray(data) ? d => d.id : null, // if tabular data, given a d in data, returns a unique identifier (string)
  parentId = Array.isArray(data) ? d => d.parentId : null, // if tabular data, given a node d, returns its parent’s identifier
  children, // if hierarchical data, given a d in data, returns its children
  value, // given a node d, returns a quantitative value (for area encoding; null for count)
  sort = (a, b) => d3.descending(a.value, b.value), // how to sort nodes prior to layout
  label, // given a leaf node d, returns the name to display on the rectangle
  group, // given a leaf node d, returns a categorical value (for color encoding)
  title, // given a leaf node d, returns its hover text
  link, // given a leaf node d, its link (if any)
  linkTarget = "_blank", // the target attribute for links (if any)
  tile = d3.treemapBinary, // treemap strategy
  width = 640, // outer width, in pixels
  height = 400, // outer height, in pixels
  margin = 0, // shorthand for margins
  marginTop = margin, // top margin, in pixels
  marginRight = margin, // right margin, in pixels
  marginBottom = margin, // bottom margin, in pixels
  marginLeft = margin, // left margin, in pixels
  padding = 1, // shorthand for inner and outer padding
  paddingInner = padding, // to separate a node from its adjacent siblings
  paddingOuter = padding, // shorthand for top, right, bottom, and left padding
  paddingTop = paddingOuter, // to separate a node’s top edge from its children
  paddingRight = paddingOuter, // to separate a node’s right edge from its children
  paddingBottom = paddingOuter, // to separate a node’s bottom edge from its children
  paddingLeft = paddingOuter, // to separate a node’s left edge from its children
  round = true, // whether to round to exact pixels
  colors = d3.schemeTableau10, // array of colors
  zDomain, // array of values for the color scale
  fill = "#ccc", // fill for node rects (if no group color encoding)
  fillOpacity = group == null ? null : 0.6, // fill opacity for node rects
  stroke, // stroke for node rects
  strokeWidth, // stroke width for node rects
  strokeOpacity, // stroke opacity for node rects
  strokeLinejoin, // stroke line join for node rects
} = {}) {

  // If id and parentId options are specified, or the path option, use d3.stratify
  // to convert tabular data to a hierarchy; otherwise we assume that the data is
  // specified as an object {children} with nested objects (a.k.a. the “flare.json”
  // format), and use d3.hierarchy.
  const root = path != null ? d3.stratify().path(path)(data)
      : id != null || parentId != null ? d3.stratify().id(id).parentId(parentId)(data)
      : d3.hierarchy(data, children);

  // Compute the values of internal nodes by aggregating from the leaves.
  value == null ? root.count() : root.sum(d => Math.max(0, value(d)));

  // Prior to sorting, if a group channel is specified, construct an ordinal color scale.
  const leaves = root.leaves();
  const G = group == null ? null : leaves.map(d => group(d.data, d));
  if (zDomain === undefined) zDomain = G;
  zDomain = new d3.InternSet(zDomain);
  const color = group == null ? null : d3.scaleOrdinal(zDomain, colors);

  // Compute labels and titles.
  const L = label == null ? null : leaves.map(d => label(d.data, d));
  const T = title === undefined ? L : title == null ? null : leaves.map(d => title(d.data, d));

  // Sort the leaves (typically by descending value for a pleasing layout).
  if (sort != null) root.sort(sort);

  // Compute the treemap layout.
  d3.treemap()
      .tile(tile)
      .size([width - marginLeft - marginRight, height - marginTop - marginBottom])
      .paddingInner(paddingInner)
      .paddingTop(paddingTop)
      .paddingRight(paddingRight)
      .paddingBottom(paddingBottom)
      .paddingLeft(paddingLeft)
      .round(round)
    (root);

  const svg = d3.create("svg")
      .attr("viewBox", [-marginLeft, -marginTop, width, height])
      .attr("width", width)
      .attr("height", height)
      .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
      .attr("font-family", "sans-serif")
      .attr("font-size", 10);

  const node = svg.selectAll("a")
    .data(leaves)
    .join("a")
      .attr("xlink:href", link == null ? null : (d, i) => link(d.data, d))
      .attr("target", link == null ? null : linkTarget)
      .attr("transform", d => `translate(${d.x0},${d.y0})`);

  node.append("rect")
      .attr("fill", color ? (d, i) => color(G[i]) : fill)
      .attr("fill-opacity", fillOpacity)
      .attr("stroke", stroke)
      .attr("stroke-width", strokeWidth)
      .attr("stroke-opacity", strokeOpacity)
      .attr("stroke-linejoin", strokeLinejoin)
      .attr("width", d => d.x1 - d.x0)
      .attr("height", d => d.y1 - d.y0);

  if (T) {
    node.append("title").text((d, i) => T[i]);
  }

  if (L) {
    // A unique identifier for clip paths (to avoid conflicts).
    const uid = `O-${Math.random().toString(16).slice(2)}`;

    node.append("clipPath")
       .attr("id", (d, i) => `${uid}-clip-${i}`)
     .append("rect")
       .attr("width", d => d.x1 - d.x0)
       .attr("height", d => d.y1 - d.y0);

    node.append("text")
        .attr("clip-path", (d, i) => `url(${new URL(`#${uid}-clip-${i}`, location)})`)
      .selectAll("tspan")
      .data((d, i) => `${L[i]}`.split(/\n/g))
      .join("tspan")
        .attr("x", 3)
        .attr("y", (d, i, D) => `${(i === D.length - 1) * 0.3 + 1.1 + i * 0.9}em`)
        .attr("fill-opacity", (d, i, D) => i === D.length - 1 ? 0.7 : null)
        .text(d => d);
  }

  return Object.assign(svg.node(), {scales: {color}});
}

    const data = [{'name': 'CN.hard coal mine operation and hard coal preparation', 'weight': 194.55252343383975}, {'name': 'GLO.treatment of waste polyethylene, open burning', 'weight': 440.865544313779}, {'name': 'RER.ethylene production, average', 'weight': 384.2260501781425}, {'name': 'RER.excavation, hydraulic digger', 'weight': 193.99221606076486}, {'name': 'RoW.ethylene production, average', 'weight': 1600.3165938519417}, {'name': 'RoW.excavation, hydraulic digger', 'weight': 392.7469237568036}, {'name': 'RoW.heat production, at hard coal industrial furnace 1-10MW', 'weight': 275.3100317588805}, {'name': 'RoW.quicklime production, in pieces, loose', 'weight': 260.6532746149125}, {'name': 'RoW.treatment of waste polyethylene, municipal incineration', 'weight': 446.2435323219946}, {'name': 'RoW.treatment of waste wire plastic, municipal incineration', 'weight': 2668.3473411019395}, {'name': 'ZA.synthetic fuel production, from coal, high temperature Fisher-Tropsch operations', 'weight': 177.67522169740982}, {'name': 'other.acetone production, liquid', 'weight': 1.6399087866448785}, {'name': 'other.aluminium production, primary, liquid, Söderberg', 'weight': 5.544129248324387}, {'name': 'other.aluminium production, primary, liquid, prebake', 'weight': 104.01773728270526}, {'name': 'other.ammonia production, partial oxidation, liquid', 'weight': 19.621901432546707}, {'name': 'other.ammonia production, steam reforming, liquid', 'weight': 21.564147879484175}, {'name': 'other.benzene production', 'weight': 9.030700431483012}, {'name': 'other.blasting', 'weight': 11.179557621299145}, {'name': 'other.butadiene production', 'weight': 3.5383823264737586}, {'name': 'other.calcium nitrate production', 'weight': 4.626554565128782}, {'name': 'other.clay brick production', 'weight': 13.61841278626098}, {'name': 'other.clinker production', 'weight': 86.91583954807273}, {'name': 'other.cobalt production', 'weight': 5.001174376478856}, {'name': 'other.coking', 'weight': 6.93822819401331}, {'name': 'other.copper mine operation and beneficiation, sulfide ore', 'weight': 8.800981085644267}, {'name': 'other.desulfurisation of hard coal flue gas', 'weight': 1.2453894868375672}, {'name': 'other.diesel production, low-sulfur, petroleum refinery operation', 'weight': 7.353162113496758}, {'name': 'other.diesel production, petroleum refinery operation', 'weight': 46.08927862949469}, {'name': 'other.diesel, burned in building machine', 'weight': 84.80689810014827}, {'name': 'other.diesel, burned in diesel-electric generating set, 10MW', 'weight': 11.341247461798641}, {'name': 'other.drying, natural gas', 'weight': 2.687345380627134}, {'name': 'other.electricity production, hard coal', 'weight': 1313.571093253962}, {'name': 'other.electricity production, hard coal, at coal mine power plant', 'weight': 31.302045033109422}, {'name': 'other.electricity production, hard coal, conventional', 'weight': 66.03263739094983}, {'name': 'other.electricity production, hard coal, supercritical', 'weight': 1.2113206525068765}, {'name': 'other.electricity production, hydro, reservoir, non-alpine region', 'weight': 1.4684978579608192}, {'name': 'other.electricity production, hydro, reservoir, tropical region', 'weight': 1.8725777774060843}, {'name': 'other.electricity production, lignite', 'weight': 212.8450182746047}, {'name': 'other.electricity production, natural gas, combined cycle power plant', 'weight': 115.2521200800227}, {'name': 'other.electricity production, natural gas, conventional power plant', 'weight': 168.69935752157681}, {'name': 'other.electricity production, oil', 'weight': 56.54868508423572}, {'name': 'other.ferrochromium production, high-carbon, 68% Cr', 'weight': 11.759299708446836}, {'name': 'other.ferronickel production', 'weight': 2.1365686689514525}, {'name': 'other.flat glass production, uncoated', 'weight': 1.3590656020257195}, {'name': 'other.hard coal mine operation', 'weight': 21.92501848372483}, {'name': 'other.hard coal mine operation and hard coal preparation', 'weight': 24.020163308531348}, {'name': 'other.hard coal mine operation, underground', 'weight': 1.4239267516340581}, {'name': 'other.heat and power co-generation, hard coal', 'weight': 47.124668123883836}, {'name': 'other.heat and power co-generation, lignite', 'weight': 28.540614201011905}, {'name': 'other.heat and power co-generation, natural gas, 1MW electrical, lean burn', 'weight': 3.8662011096795044}, {'name': 'other.heat and power co-generation, natural gas, 200kW electrical, lean burn', 'weight': 2.183911337278726}, {'name': 'other.heat and power co-generation, natural gas, 500kW electrical, lean burn', 'weight': 1.6959626808911659}, {'name': 'other.heat and power co-generation, natural gas, combined cycle power plant, 400MW electrical', 'weight': 10.712667128561243}, {'name': 'other.heat and power co-generation, natural gas, conventional power plant, 100MW electrical', 'weight': 69.88044363755519}, {'name': 'other.heat production, anthracite, at stove 5-15kW', 'weight': 2.3607549821501053}, {'name': 'other.heat production, at coal coke industrial furnace 1-10MW', 'weight': 7.0687482105305}, {'name': 'other.heat production, at hard coal industrial furnace 1-10MW', 'weight': 18.947001280599096}, {'name': 'other.heat production, heavy fuel oil, at industrial furnace 1MW', 'weight': 39.99628453441385}, {'name': 'other.heat production, light fuel oil, at boiler 100kW, non-modulating', 'weight': 1.8902577297962748}, {'name': 'other.heat production, light fuel oil, at industrial furnace 1MW', 'weight': 45.69834591046257}, {'name': 'other.heat production, natural gas, at boiler condensing modulating >100kW', 'weight': 3.1724286864334807}, {'name': 'other.heat production, natural gas, at boiler modulating >100kW', 'weight': 11.62139456263101}, {'name': 'other.heat production, natural gas, at industrial furnace >100kW', 'weight': 85.64310994271092}, {'name': 'other.heat production, natural gas, at industrial furnace low-NOx >100kW', 'weight': 4.009683710053128}, {'name': 'other.heat production, propane, at industrial furnace >100kW', 'weight': 1.2116857621095378}, {'name': 'other.heavy fuel oil production, petroleum refinery operation', 'weight': 5.459807665290074}, {'name': 'other.iron sinter production', 'weight': 15.108468686751493}, {'name': 'other.light fuel oil production, petroleum refinery operation', 'weight': 1.9353008245698062}, {'name': 'other.lignite mine operation', 'weight': 1.2486872637402877}, {'name': 'other.market for electricity, medium voltage', 'weight': 1.329118914934778}, {'name': 'other.market for electricity, medium voltage, aluminium industry', 'weight': 2.502811377510239}, {'name': 'other.market for electricity, medium voltage, cobalt industry', 'weight': 2.605390121231146}, {'name': 'other.market for natural gas, high pressure', 'weight': 1.1693299571495033}, {'name': 'other.market for natural gas, low pressure', 'weight': 1.1252886381198768}, {'name': 'other.municipal waste collection service by 21 metric ton lorry', 'weight': 2.8965315336425523}, {'name': 'other.natural gas production', 'weight': 23.697947226779355}, {'name': 'other.natural gas production, unprocessed, at extraction', 'weight': 10.083206226978549}, {'name': 'other.natural gas venting from petroleum/natural gas production', 'weight': 13.50059010759845}, {'name': 'other.natural gas, burned in gas motor, for storage', 'weight': 6.9259182677711575}, {'name': 'other.natural gas, burned in gas turbine, for compressor station', 'weight': 12.750834076042114}, {'name': 'other.nitric acid production, product in 50% solution state', 'weight': 43.014453429205965}, {'name': 'other.petroleum coke production, petroleum refinery operation', 'weight': 2.566727494336848}, {'name': 'other.pig iron production', 'weight': 38.34780563874255}, {'name': 'other.pitch production, petroleum refinery operation', 'weight': 1.597856182084485}, {'name': 'other.polyethylene production, high density, granulate', 'weight': 51.11191664071067}, {'name': 'other.propylene production', 'weight': 5.05666775883803}, {'name': 'other.quicklime production, in pieces, loose', 'weight': 1.4889754712236285}, {'name': 'other.refinery gas, burned in furnace', 'weight': 2.310467361517284}, {'name': 'other.silicon production, metallurgical grade', 'weight': 2.501687777817609}, {'name': 'other.smelting of copper concentrate, sulfide ore', 'weight': 15.770676244913629}, {'name': 'other.sour gas, burned in gas turbine', 'weight': 1.8955881826229448}, {'name': 'other.sponge iron production', 'weight': 1.980589143815779}, {'name': 'other.steel production, converter, low-alloyed', 'weight': 1.4220175980433454}, {'name': 'other.steel production, converter, unalloyed', 'weight': 1.7614603411743253}, {'name': 'other.steel production, electric, chromium steel 18/8', 'weight': 1.1765475122166833}, {'name': 'other.sweet gas, burned in gas turbine', 'weight': 24.55068798785454}, {'name': 'other.sweetening, natural gas', 'weight': 2.776324620711543}, {'name': 'other.titanium dioxide production, chloride process', 'weight': 1.5747245005218327}, {'name': 'other.toluene production, liquid', 'weight': 2.4875882705119228}, {'name': 'other.transport, freight train, diesel', 'weight': 25.57902633169383}, {'name': 'other.transport, freight, inland waterways, barge', 'weight': 2.856777303864101}, {'name': 'other.transport, freight, light commercial vehicle', 'weight': 3.683271513792702}, {'name': 'other.transport, freight, lorry 16-32 metric ton, EURO3', 'weight': 21.52028288528927}, {'name': 'other.transport, freight, lorry 16-32 metric ton, EURO4', 'weight': 15.043324401166853}, {'name': 'other.transport, freight, lorry 16-32 metric ton, EURO5', 'weight': 7.48375716266989}, {'name': 'other.transport, freight, lorry 3.5-7.5 metric ton, EURO3', 'weight': 5.6650204598808305}, {'name': 'other.transport, freight, lorry 3.5-7.5 metric ton, EURO4', 'weight': 2.9796895181907854}, {'name': 'other.transport, freight, lorry 3.5-7.5 metric ton, EURO5', 'weight': 3.164474364389498}, {'name': 'other.transport, freight, lorry 7.5-16 metric ton, EURO3', 'weight': 2.919914683464686}, {'name': 'other.transport, freight, lorry 7.5-16 metric ton, EURO4', 'weight': 1.6787457109723445}, {'name': 'other.transport, freight, lorry 7.5-16 metric ton, EURO5', 'weight': 1.6848656439334757}, {'name': 'other.transport, freight, lorry >32 metric ton, EURO3', 'weight': 19.65989860245548}, {'name': 'other.transport, freight, lorry >32 metric ton, EURO4', 'weight': 16.22830330363694}, {'name': 'other.transport, freight, lorry >32 metric ton, EURO5', 'weight': 10.478776448963462}, {'name': 'other.transport, freight, sea, bulk carrier for dry goods', 'weight': 13.480252455221422}, {'name': 'other.transport, freight, sea, container ship', 'weight': 15.884338337752453}, {'name': 'other.transport, freight, sea, tanker for liquefied natural gas', 'weight': 1.3554014901938982}, {'name': 'other.transport, freight, sea, tanker for petroleum', 'weight': 8.716722846783846}, {'name': 'other.transport, pipeline, long distance, natural gas', 'weight': 8.507103323029202}, {'name': 'other.transport, pipeline, onshore, long distance, natural gas', 'weight': 2.149116511692742}, {'name': 'other.treatment of blast furnace gas, in power plant', 'weight': 5.222026153751332}, {'name': 'other.treatment of hazardous waste, hazardous waste incineration', 'weight': 2.3219089750036357}, {'name': 'other.treatment of hazardous waste, hazardous waste incineration, with energy recovery', 'weight': 2.3219089750036357}, {'name': 'other.treatment of municipal solid waste, open dump, wet infiltration class (500mm)', 'weight': 1.1936871143640295}, {'name': 'other.treatment of municipal solid waste, unsanitary landfill, wet infiltration class (500mm)', 'weight': 1.9715119753678505}, {'name': 'other.treatment of waste graphical paper, unsanitary landfill, wet infiltration class (500mm)', 'weight': 1.4682890464406904}, {'name': 'other.treatment of waste mineral oil, hazardous waste incineration', 'weight': 5.750556451296353}, {'name': 'other.treatment of waste mineral oil, hazardous waste incineration, with energy recovery', 'weight': 5.752518610161457}, {'name': 'other.treatment of waste natural gas, sour, burned in production flare', 'weight': 8.889470524448532}, {'name': 'other.treatment of waste natural gas, sweet, burned in production flare', 'weight': 15.213569389925537}, {'name': 'other.treatment of waste polyethylene, open dump, dry infiltration class (100mm)', 'weight': 9.799917599654748}, {'name': 'other.treatment of waste polyethylene, open dump, hyperarid infiltration class (-250mm)', 'weight': 4.734127338435163}, {'name': 'other.treatment of waste polyethylene, open dump, moist infiltration class (300mm)', 'weight': 4.91858034382219}, {'name': 'other.treatment of waste polyethylene, open dump, very wet infiltration class (1000mm)', 'weight': 11.390612883854622}, {'name': 'other.treatment of waste polyethylene, open dump, wet infiltration class (500mm)', 'weight': 30.226620763366356}, {'name': 'other.treatment of waste polyethylene, unsanitary landfill, dry infiltration class (100mm)', 'weight': 18.73886700048794}, {'name': 'other.treatment of waste polyethylene, unsanitary landfill, hyperarid infiltration class (-250mm)', 'weight': 9.153301571598096}, {'name': 'other.treatment of waste polyethylene, unsanitary landfill, moist infiltration class (300mm)', 'weight': 16.269308001505614}, {'name': 'other.treatment of waste polyethylene, unsanitary landfill, very wet infiltration class (1000mm)', 'weight': 20.67689663341544}, {'name': 'other.treatment of waste polyethylene, unsanitary landfill, wet infiltration class (500mm)', 'weight': 61.31753856121488}, {'name': 'other.treatment of waste rubber, unspecified, municipal incineration', 'weight': 1.2440657300917615}, {'name': 'other.xylene production', 'weight': 2.6026246100653325}, {'name': 'other.zinc mine operation', 'weight': 2.8024122913257115}, {'name': 'other', 'size': 'null'}, {'name': 'GLO', 'size': 'null'}, {'name': 'RoW', 'size': 'null'}, {'name': 'RER', 'size': 'null'}, {'name': 'CN', 'size': 'null'}, {'name': 'ZA', 'size': 'null'}];


    document.addEventListener('DOMContentLoaded', function () {
        chart = Treemap(data, {
          path: d => d.name.replace(/\./g, "/"),
          value: d => d?.weight, // size of each node (file); null for internal nodes (folders)
          group: d => d.name.split(".")[0],
          label: (d, n) => [...d.name.split(".").pop().split(/(?=[A-Z][a-z])/g), n.value.toLocaleString("en")].join("\n"),
          title: (d, n) => `${d.name}\n${n.value.toLocaleString("en")}`, // text to show on hover
          tile: d3.treemapBinary, // e.g., d3.treemapBinary; set by input above
          width: 1200,
          height: 1200
        })

        document.getElementById("chart").appendChild(chart);
        key = Swatches(chart.scales.color)
        document.getElementById("legend").appendChild(key);
    });



</script>

<div id="legend" style="margin-left:5px;margin-top:5px;width:1000px;height:50px"></div>
<div id="chart" style="margin-left:5px;margin-top:5px;width:1000px;height:500px"></div>

</body>
</html>